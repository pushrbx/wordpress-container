name: WordPress Apache Image Mirror

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: pushrbx/wordpress-container
  MIN_VERSION: "6.7.0"

jobs:
  check-and-build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Get WordPress apache tag groups from Docker Hub (6.7.0+)
      id: get-tags
      run: |
        set -euo pipefail

        echo "Fetching WordPress apache tags from Docker Hub..."

        # Function to compare versions using sort -V
        version_gte() {
          local version1="$1"
          local version2="$2"

          if [ "$(printf '%s\n%s' "$version2" "$version1" | sort -V | head -n1)" = "$version2" ]; then
            return 0
          else
            return 1
          fi
        }

        # Function to extract version from tag
        extract_version() {
          local tag="$1"
          local version=""

          if [[ "$tag" =~ ^([0-9]+\.[0-9]+\.[0-9]+) ]]; then
            version="${BASH_REMATCH[1]}"
          elif [[ "$tag" =~ ^([0-9]+\.[0-9]+) ]]; then
            version="${BASH_REMATCH[1]}.0"
          elif [[ "$tag" =~ ^([0-9]+)- ]] || [[ "$tag" =~ ^([0-9]+)$ ]]; then
            version="${BASH_REMATCH[1]}.0.0"
          fi

          echo "$version"
        }

        # Get tags from Docker Hub API
        echo "Fetching tags from Docker Hub API..."
        TAGS_JSON=$(curl -s "https://hub.docker.com/v2/repositories/library/wordpress/tags/?page_size=100" || echo '{"results":[]}')

        # Extract all tag names
        ALL_TAGS=$(echo "$TAGS_JSON" | jq -r '.results[]?.name // empty' 2>/dev/null || echo "")

        if [ -z "$ALL_TAGS" ]; then
          echo "Warning: No tags found from API"
          echo "tag-groups=" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "Total tags found: $(echo "$ALL_TAGS" | wc -l)"

        # Define tag groups based on WordPress upstream structure
        # Each group represents tags that should point to the same image
        declare -A TAG_GROUPS
        declare -A PROCESSED_TAGS

        # Process all tags and group them
        while IFS= read -r tag; do
          [ -z "$tag" ] && continue
          [[ "${PROCESSED_TAGS[$tag]:-}" == "1" ]] && continue

          # Only process apache tags for version 6+
          if [[ "$tag" == *"apache"* ]]; then
            VERSION=$(extract_version "$tag")

            # Skip if version is less than minimum
            if [ -n "$VERSION" ] && ! version_gte "$VERSION" "${{ env.MIN_VERSION }}"; then
              echo "Skipping $tag (version $VERSION < ${{ env.MIN_VERSION }})"
              continue
            fi

            # Determine the canonical source tag (most specific version)
            SOURCE_TAG=""
            GROUP_TAGS=""

            # For PHP 8.3 apache (default) - these all share the same image
            if [[ "$tag" =~ ^6\.9\.0-apache$ ]] || [[ "$tag" =~ ^6\.9-apache$ ]] || [[ "$tag" =~ ^6-apache$ ]] || [[ "$tag" == "apache" ]] || \
               [[ "$tag" =~ ^6\.9\.0$ ]] || [[ "$tag" =~ ^6\.9$ ]] || [[ "$tag" == "6" ]] || [[ "$tag" == "latest" ]] || \
               [[ "$tag" =~ ^6\.9\.0-php8\.3-apache$ ]] || [[ "$tag" =~ ^6\.9-php8\.3-apache$ ]] || [[ "$tag" =~ ^6-php8\.3-apache$ ]] || [[ "$tag" == "php8.3-apache" ]] || \
               [[ "$tag" =~ ^6\.9\.0-php8\.3$ ]] || [[ "$tag" =~ ^6\.9-php8\.3$ ]] || [[ "$tag" =~ ^6-php8\.3$ ]] || [[ "$tag" == "php8.3" ]]; then

              SOURCE_TAG="6.9.0-php8.3-apache"  # Use the most specific tag as source
              GROUP_KEY="php8.3-apache"

              # Find all related tags for this group
              for related_tag in "6.9.0-apache" "6.9-apache" "6-apache" "apache" "6.9.0" "6.9" "6" "latest" \
                                "6.9.0-php8.3-apache" "6.9-php8.3-apache" "6-php8.3-apache" "php8.3-apache" \
                                "6.9.0-php8.3" "6.9-php8.3" "6-php8.3" "php8.3"; do
                if echo "$ALL_TAGS" | grep -q "^${related_tag}$"; then
                  if [ -z "$GROUP_TAGS" ]; then
                    GROUP_TAGS="$related_tag"
                  else
                    GROUP_TAGS="$GROUP_TAGS,$related_tag"
                  fi
                  PROCESSED_TAGS["$related_tag"]="1"
                fi
              done

            # For other PHP versions with apache
            elif [[ "$tag" =~ ^6\.9\.0-php([0-9]+\.[0-9]+)-apache$ ]] || [[ "$tag" =~ ^6\.9-php([0-9]+\.[0-9]+)-apache$ ]] || \
                 [[ "$tag" =~ ^6-php([0-9]+\.[0-9]+)-apache$ ]] || [[ "$tag" =~ ^php([0-9]+\.[0-9]+)-apache$ ]] || \
                 [[ "$tag" =~ ^6\.9\.0-php([0-9]+\.[0-9]+)$ ]] || [[ "$tag" =~ ^6\.9-php([0-9]+\.[0-9]+)$ ]] || \
                 [[ "$tag" =~ ^6-php([0-9]+\.[0-9]+)$ ]] || [[ "$tag" =~ ^php([0-9]+\.[0-9]+)$ ]]; then

              # Extract PHP version
              PHP_VERSION=""
              if [[ "$tag" =~ php([0-9]+\.[0-9]+) ]]; then
                PHP_VERSION="${BASH_REMATCH[1]}"
              fi

              if [ -n "$PHP_VERSION" ]; then
                SOURCE_TAG="6.9.0-php${PHP_VERSION}-apache"
                GROUP_KEY="php${PHP_VERSION}-apache"

                # Find all related tags for this PHP version
                for related_tag in "6.9.0-php${PHP_VERSION}-apache" "6.9-php${PHP_VERSION}-apache" "6-php${PHP_VERSION}-apache" "php${PHP_VERSION}-apache" \
                                  "6.9.0-php${PHP_VERSION}" "6.9-php${PHP_VERSION}" "6-php${PHP_VERSION}" "php${PHP_VERSION}"; do
                  if echo "$ALL_TAGS" | grep -q "^${related_tag}$"; then
                    if [ -z "$GROUP_TAGS" ]; then
                      GROUP_TAGS="$related_tag"
                    else
                      GROUP_TAGS="$GROUP_TAGS,$related_tag"
                    fi
                    PROCESSED_TAGS["$related_tag"]="1"
                  fi
                done
              fi
            fi

            # Add the group if we found tags
            if [ -n "$SOURCE_TAG" ] && [ -n "$GROUP_TAGS" ]; then
              TAG_GROUPS["$GROUP_KEY"]="$SOURCE_TAG|$GROUP_TAGS"
              echo "Created group $GROUP_KEY: $SOURCE_TAG -> $GROUP_TAGS"
            fi
          fi
        done <<< "$ALL_TAGS"

        # Convert tag groups to JSON for output
        TAG_GROUPS_JSON="{"
        FIRST=true
        for group_key in "${!TAG_GROUPS[@]}"; do
          IFS='|' read -r source_tag group_tags <<< "${TAG_GROUPS[$group_key]}"

          if [ "$FIRST" = true ]; then
            FIRST=false
          else
            TAG_GROUPS_JSON="$TAG_GROUPS_JSON,"
          fi

          TAG_GROUPS_JSON="$TAG_GROUPS_JSON\"$group_key\":{\"source\":\"$source_tag\",\"tags\":\"$group_tags\"}"
        done
        TAG_GROUPS_JSON="$TAG_GROUPS_JSON}"

        echo "Tag groups JSON: $TAG_GROUPS_JSON"
        echo "tag-groups=$TAG_GROUPS_JSON" >> $GITHUB_OUTPUT

    - name: Check existing tags in GHCR
      id: check-existing
      if: steps.get-tags.outputs.tag-groups != ''
      run: |
        set -euo pipefail

        echo "Checking existing tags in GHCR..."
        TAG_GROUPS='${{ steps.get-tags.outputs.tag-groups }}'
        NEW_GROUPS=""

        # Check each group
        for group_key in $(echo "$TAG_GROUPS" | jq -r 'keys[]'); do
          group_tags=$(echo "$TAG_GROUPS" | jq -r ".[\"$group_key\"].tags")

          # Check if any tag in the group is missing
          GROUP_NEEDS_BUILD=false
          IFS=',' read -ra TAGS_ARRAY <<< "$group_tags"

          for tag in "${TAGS_ARRAY[@]}"; do
            if ! docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$tag >/dev/null 2>&1; then
              echo "Tag $tag is missing, group $group_key needs build"
              GROUP_NEEDS_BUILD=true
              break
            fi
          done

          if [ "$GROUP_NEEDS_BUILD" = true ]; then
            if [ -z "$NEW_GROUPS" ]; then
              NEW_GROUPS="$group_key"
            else
              NEW_GROUPS="$NEW_GROUPS,$group_key"
            fi
          else
            echo "All tags for group $group_key exist"
          fi
        done

        echo "new-groups=$NEW_GROUPS" >> $GITHUB_OUTPUT
        echo "Groups to build: $NEW_GROUPS"

    - name: Build and push image groups with caching
      if: steps.check-existing.outputs.new-groups != ''
      run: |
        set -euo pipefail

        TAG_GROUPS='${{ steps.get-tags.outputs.tag-groups }}'
        IFS=',' read -ra GROUPS_ARRAY <<< "${{ steps.check-existing.outputs.new-groups }}"

        for group_key in "${GROUPS_ARRAY[@]}"; do
          if [ -n "$group_key" ]; then
            source_tag=$(echo "$TAG_GROUPS" | jq -r ".[\"$group_key\"].source")
            group_tags=$(echo "$TAG_GROUPS" | jq -r ".[\"$group_key\"].tags")

            echo "Building group: $group_key"
            echo "Source tag: $source_tag"
            echo "Target tags: $group_tags"

            # Create Dockerfile from template
            sed "s/{{TAG}}/$source_tag/g" Dockerfile.template > Dockerfile.build

            echo "Generated Dockerfile:"
            cat Dockerfile.build

            # Prepare all tags for the build
            BUILD_TAGS=""
            IFS=',' read -ra TAGS_ARRAY <<< "$group_tags"
            for tag in "${TAGS_ARRAY[@]}"; do
              BUILD_TAGS="$BUILD_TAGS --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$tag"
            done

            # Create cache key based on source tag
            CACHE_KEY="wordpress-apache-$source_tag"

            # Build and push the image with all tags and GitHub Actions cache
            docker buildx build \
              --platform linux/amd64,linux/arm64 \
              --file Dockerfile.build \
              --cache-from type=gha,scope=$CACHE_KEY \
              --cache-to type=gha,mode=max,scope=$CACHE_KEY \
              $BUILD_TAGS \
              --push \
              .

            # Clean up
            rm Dockerfile.build

            echo "Successfully built and pushed group $group_key with tags: $group_tags"
          fi
        done

    - name: Summary
      run: |
        echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Registry**: ${{ env.REGISTRY }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Image**: ${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Minimum Version**: ${{ env.MIN_VERSION }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Caching**: GitHub Actions cache enabled with buildx" >> $GITHUB_STEP_SUMMARY

        NEW_GROUPS="${{ steps.check-existing.outputs.new-groups || '' }}"
        if [ -n "$NEW_GROUPS" ]; then
          echo "- **New groups built**: $NEW_GROUPS" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Result**: No new groups to build" >> $GITHUB_STEP_SUMMARY
        fi

        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Tag Groups Structure" >> $GITHUB_STEP_SUMMARY
        echo '```json&#x27; &gt;&gt; $GITHUB_STEP_SUMMARY
        echo &#x27;${{ steps.get-tags.outputs.tag-groups }}&#x27; &gt;&gt; $GITHUB_STEP_SUMMARY
        echo &#x27;```' >> $GITHUB_STEP_SUMMARY